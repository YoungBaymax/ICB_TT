# math functions
from math import sqrt, atan

# Debug
from log import Log
log = Log("Posture")
log.setVerbose(False)

## Defines size of the buffers for offset calculation
BUFFER_SIZE = 10


## Posture estimation based on accelerometer used as a compensated tilt sensor.
#
# The algoritm calculates the offset due to earth's gravity in the
# accelerometer axis, provided no other accelerations or forces affects the
# accelerometer.
#
# The algorithm then determinates the tilt componsated with the estimated
# position of the gravity, to ensure the measurements are always equals in the
# coordinates of the accelerometer.
# @author Sebastian Sepulveda
class Posture:
    std = .05
    g = [0]*3

    ## Constructor
    def __init__(self):
        log.d('Init')
        self.resetBuffers()

    ## Determinates the offset in the accelerometer.
    #
    # When the accelerometer is static, it's readings should show the effect
    # of the gravity in accelerometer (while it's inside the earth's
    # gravitational force). Therefore, if no other force (normalized magnitud
    # equal to 1 g) the direction of the gravity force could be estimated
    #
    # An @ref std value is defined for the desviation in the values acceptables
    # @param self The object pointer.
    # @param x Acceleration in the x axis, in g
    # @param y Acceleration in the y axis, in g
    # @param z Acceleration in the z axis, in g
    def offset(self, x, y, z):
        # obtain magnitude of the acceleration
        A = sqrt(x*x + y*y + z*z)
        # if the value of magnitud is between the std range, is assumed that
        # no other value than the gravity as been measured
        if A < 1+self.std and A > 1-self.std:
            self.X.append(x)
            self.Y.append(y)
            self.Z.append(z)

            # when measurement size is reached, mean all and normalize
            if len(self.X) >= BUFFER_SIZE:
                g = [0]*3
                g[0] = self.normalize(self.mean(self.X))
                g[1] = self.normalize(self.mean(self.Y))
                g[2] = self.normalize(self.mean(self.Z))
                self.resetBuffers()

                if g != [0, 0, 0]:
                    log.v('Estimated gravity vector ['+str(self.g[0])+' ' +
                          str(self.g[1])+' '+str(self.g[2])+']')
                    self.g = g

    ## Compesated tilt.
    #
    # Using the data generated by @ref offset, modifies axis values gatered so
    # the tilt is always measured properly, based on this considerations:
    #
    # + The earth's gravity is aligned with the z axis (axis pointing in
    # direction of the earth's gravity)
    # + The Y axis points to the front of the user
    # + The X axis points to the right of the user
    #
    # With this considerations, the rest of the modifications based on the
    # displacement of the earth's gravity are reorder to calculate the tilt
    # alway in reference to the earth's gravity
    # @param self The object pointer.
    # @param x Acceleration in the x axis, in g
    # @param y Acceleration in the y axis, in g
    # @param z Acceleration in the z axis, in g
    def compensatedTilt(self, x, y, z):
        if self.g == [0, 0, 1]:
            ref = z
            front = y
            lateral = x
        elif self.g == [0, 1, 0]:
            ref = y
            front = -x
            lateral = -z
        elif self.g == [1, 0, 0]:
            ref = x
            front = y
            lateral = -z
        elif self.g == [0, 0, -1]:
            ref = -z
            front = y
            lateral = -x
        elif self.g == [0, -1, 0]:
            ref = -y
            front = -x
            lateral = z
        elif self.g == [-1, 0, 0]:
            ref = -x
            front = y
            lateral = z
        else:
            log.w('No data detected, using last or expected values')
            ref = z
            front = y
            lateral = x

        if self.g != [0, 0, 0]:
            self.angle_frontal = atan(front/sqrt(lateral*lateral + ref*ref))
            self.angle_lateral = atan(lateral/sqrt(front*front + ref*ref))
            log.v('Tilt : ['+str(self.angle_frontal)+', ' +
                  str(self.angle_lateral)+']')
        else:
            self.angle_frontal = 0
            self.angle_lateral = 0

    ## Normalizes de values of the gravity
    #
    # Normalizes values in 3 ranges, using the @ref std as desviation from the
    # expected values
    # @param self The object pointer.
    # @param value Value to be normalized
    # @return normalized values
    # + @b 1 if the gravity points in the direction of the axis
    # + @b 0 if the gravity was not detected in the axis
    # + @b 1 if the gravity points in the opposite direction of the axis
    def normalize(self, value):
        if value < 1+self.std and value > 1-self.std:
            value = 1
        elif value < -1+self.std and value > -1-self.std:
            value = -1
        else:
            value = 0
        return value

    ## Average of a list of values
    #
    # @param self The object pointer.
    # @param list_ list with values
    # @return Average of the List
    def mean(self, list_):
        size = len(list_)
        sum_ = 0
        for i in range(0, size):
            sum_ += list_[i]
        return sum_/size

    ## Clean buffers
    #
    # @param self The object pointer.
    def resetBuffers(self):
        self.X = []
        self.Y = []
        self.Z = []

    ## Getter for the tilt values
    #
    # @param self The object pointer.
    # @param x Acceleration in the x axis, in g
    # @param y Acceleration in the y axis, in g
    # @param z Acceleration in the z axis, in g
    # @return A list with 2 elements
    # + @b 1st Position show the tilt inclination.
    #     + @b Positive values means front inclination
    #     + @b Negative values means backwards inclination
    # + @b 2nd Position show the tilt inclination.
    #     + @b Positive values means right inclination
    #     + @b Negative values means left inclination
    def getTilt(self, x, y, z):
        self.compensatedTilt(x, y, z)
        return [self.angle_frontal, self.angle_lateral]

if __name__ == "__main__":
    import os
    os.system("python main.py")
